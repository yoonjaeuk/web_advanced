# 이동인 - BOJ_1939
### 오답
다익스트라 알고리즘을 변형하는 방식으로 문제에 접근하였으나,
중간에 다익스트라 알고리즘을 변형하지 않고 그대로 사용하느라 시간을 낭비함.

### 설계
출발 노드 s와 임의의 노드 index 간에 현재 구할 수 있는 최대 중량제한을 계속해서 업데이트하고, 확정 가능한 최대 중량제한을 확정한다. 목표 노드인 e노드에 대해 최대 중량제한을 확정할 수 있으면 프로그램을 종료한다.

#### 어떻게 최대 중량제한을 정하고 업데이트 하는가?
현재 노드 temp (출발할 때 현재 노드는 s 노드이기 때문에 temp는 s로 초기화) 와 연결된 다음 노드 candidate를 방문할 떄,
temp노드까지의 최대 중량 제한이 없다면(s==temp일 때 temp 노드까지의 최대 중량 제한이 없을 것이고 이 때 최대 중량 제한은 편의상 0으로 설정한다.), candidate 까지의 최대 중량 제한은 temp - candidate간의 중량 제한 값으로 정해진다.
temp노드까지의 최대 중량 제한이 있다면 candidate 노드까지의 최대 중량 제한은, 현재 candidate 노드까지의 최대 중량 제한과 temp를 거쳐가는 루트의 최대 중량제한 중 큰 값으로 정한다.

- 추가 설명  
candidate 노드까지의 현재 최대 중량 제한을 current_candidate_limit라고 하고, temp 노드까지의 현재 최대 중량 제한을 current_temp_limit라고하자.
temp 노드와 candidate 노드 사이의 중량 제한을 new_limit라고 할때
candidate 노드가지의 현재 최대 중량 제한은 max(current_candidate_limit, min(current_temp_limit, new_limit))으로 업데이트 된다.

#### 어떻게 확정 가능한 최대 중량 제한을 알 수 있고 이유는 무엇인가?
s 로부터 최대 중량 제한이 확정 되지 않은 모든 index 노드는 현재까지의 최대 중량 제한 max_limit[index]값을 갖고 있다.
이 중에 최댓값을 갖고 있는 index노드는 s로부터 최대 중량제한을 max_limit[index]로 확정할 수 있다.
그 이유는, 각 노드 별로 0으로 초기화된 최대 중량 제한 값은, 0 초과의 값으로 업데이트 된 이후에는 
```
current_candidate_limit = max(current_candidate_limit, min(current_temp_limit, new_limit))
``` 
식에 따라 계속해서 non-increaseing 하게 업데이트 되며, 새로운 경로의 최대 중량 제한이 현재 최대 중량 제한보다 작은 경우 현재 최대 중량 제한은 업데이트 되지 않는다.
따라서 최대 중량 제한 값이 최대인 노드는 최대 중량 제한 값을 확정할 수 있다.

#### 프로그램 종료 조건
최대 중량 제한을 확정하는 노드가 e인 경우 답(s로부터 e까지의 최대 중량제한)을 출력하고 프로그램을 종료한다.
문제에 최대 중량제한이 있을 때만 입력이 주어진다는 조건이 있기 때문에 항상 도중에 탈출 가능하고, 반복문 탈출 조건을 주지 않아도 된다.

### 느낀점
문제를 꼼꼼히 읽자.